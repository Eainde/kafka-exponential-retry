# ===================================================================
# Kafka Retry Library Configuration
# ===================================================================
kafka:
  retry:
    # Set to true to activate the entire retry mechanism
    enabled: true

    # The first retry will happen after 5 minutes
    initial-interval-minutes: 5

    # A message will be retried a maximum of 5 times
    max-retries: 5

    # The scheduler will fetch a maximum of 100 records per run
    batch-size: 100

    # The scheduler will check for messages to retry every minute
    cron: "0 */1 * * * *"

    # --- Exception Control Settings ---
    # RULE 1: THE BLACKLIST (Fatal Errors)
    # Any exception listed here (or its subclasses) will NEVER be retried.
    # The message will be immediately marked as PERMANENT_FAILURE.
    # This list always takes precedence.
    non-retryable-exceptions:
      # For bad data that will never be valid.
      - java.lang.IllegalArgumentException
      # For messages that cannot be deserialized.
      - org.springframework.messaging.converter.MessageConversionException
      # An example of a custom, non-recoverable business exception.
      - com.mycompany.exceptions.PermanentBusinessLogicException

    # RULE 2: THE WHITELIST (Transient Errors)
    # OPTIONAL: If you define this list, ONLY exceptions listed here will be retried
    # (as long as they are not on the blacklist).
    # If this list is empty, then ALL exceptions not on the blacklist are retried by default.
    retryable-exceptions:
      # For temporary network issues.
      - java.net.SocketTimeoutException
      # For when a downstream REST API is temporarily unavailable.
      - org.springframework.web.client.HttpServerErrorException
      # For database lock conflicts that might resolve on the next attempt.
      - org.springframework.dao.PessimisticLockingFailureException
      # An example of a custom, recoverable business exception.
      - com.mycompany.exceptions.TransientDataConflictException

    # --- Handler Mappings: The Core of the Routing Logic ---
    # This section links dynamic/environment-specific topic names to
    # the static, logical bean names of your RetryMessageHandler implementations.
    handler-mappings:
      # == CONSUMER EXAMPLE ==
      # This mapping is for handling failures when CONSUMING from an order topic.
      # If a message from 'cl.uk.prod.order-events.rt' fails, it will be
      # routed to the Spring bean named 'orderEventsHandler'.
      orderEventsHandler: "cl.uk.*.order-events.rt"

      # == PRODUCER EXAMPLE ==
      # This mapping is for handling failures when PRODUCING to a shipment topic.
      # If the service tries to send a message to 'cl.uk.dev.shipment-notifications.rt'
      # and it fails (e.g., Kafka is down), it will be saved and later routed
      # to the Spring bean named 'shipmentNotificationHandler'.
      shipmentNotificationHandler: "cl.uk.*.shipment-notifications.rt"

      # == UNIFIED LOGIC EXAMPLE ==
      # In some cases, the same logic might apply. For example, processing a KYC
      # update might involve both consuming an event and producing a result.
      # The same handler can be used for both.
      kycUpdateHandler: "cl.uk.*.kyc-update.rt"
